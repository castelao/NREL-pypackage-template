# {{ project_name }} Coding Agent Onboarding Guide

## 1. Project Description
{{ package_short_description }}

## 2. Tech Stack Overview
- Environment management: **Pixi** environments (`default`, `dev`, `test`,
  `doc`, `build`). Always prefer Pixi over bare pip for dependency
  consistency.
- Packaging/versioning: `setuptools_scm` (version in `{{ project_slug }}/_version.py`
  generated dynamically by tags `vX.Y.Z`).
- Linting/Formatting: Ruff (configured in `pyproject.toml`). Line length 79
  (72 for docstrings). Ruff also runs format checks.
- Testing: Pytest (unit-style and integration-style cases in `tests/`),
  coverage via `pytest-cov`, optional parallel runs through `pytest-xdist`.
- Docs: Sphinx (doc extra) and guides (`README.rst`, `INSTALL.md`),
  published on GitHub Pages.
- CLI: Click entry point `{{ project_slug }}.cli:main` orchestrates code execution.

## 3. Environment & Commands Cheat Sheet
Always prefer Pixi; it encodes supported dependency sets:
```
# Sync and enter development environment
pixi install --frozen -e dev
pixi shell -e dev

# Linting and formatting
pixi run -e dev ruff check .
pixi run -e dev ruff format .

# Run tests
pixi run -e test pytest

# Run tests with coverage
pixi run -e test tests

# CLI smoke test
pixi run -e dev {{ project_slug }} --help

# Build docs (when editing Sphinx docs)
pixi run -e doc python-docs

# Build distribution artifacts
pixi run -e build build-wheels
```
To add a new dependency, use `pixi add <package>`; this updates `pyproject.toml` and the lockfile atomically.
Use `pixi add --feature dev <package>` to add a dependency that is only used for development (tests, linting, docs, etc.).


## 4. Coding Guidelines (Python)
- Follow the repository style guide: keep numpy-style docstrings,
  prefer protected helpers until APIs stabilize, and mirror
  existing naming/visibility patterns.
- Follow Ruff configuration (79 char lines, 72 char lines for docstrings,
  double quotes, numpy docstyle). Run locally: `pixi run -e dev ruff check .`
  and `pixi run -e dev ruff format .`
- Do not add comments unless they are absolutely critical to understanding;
  always prefer descriptive function and variable names instead.
- Use absolute imports under `{{ project_slug }}.`.
- Version: Never edit `_version.py` manually (auto-generated by `setuptools_scm`). Tag releases `vX.Y.Z`.
- Exceptions: Always raise specific custom exceptions from
  `{{ project_slug }}.exceptions` (e.g., `{{ project_slug | upper }}ValueError`). Add new exceptions
  to this module if appropriate.

## 5. Docstring Guidelines (Python)
- Use numpy-style docstrings to document classes, methods, and functions.
- Keep docstring length to 72 characters per line.
- Do not add a short summary to __init__ methods. Instead, keep the line blank and start the "Parameters" section after a second newline.
- Do not document parameters in the class docstring - do that in the __init__ docstring instead.
- Do not add docstring to dunder methods (e.g., __str__, __repr__, etc.) unless absolutely necessary.
- All @property and @cached_property method documentation should be one line long and should start with the return type followed by a colon (e.g. `"""str: My string property"""`).
- If the default value for a parameter is **not** `None`, document it using the format: `param_name : type, default=<default value>`. If the default value for a parameter **is** `None`, use the format : `param_name : type, optional`.
- "Protected" functions and methods (i.e. starting with an underscore) should always be documented using **only** one-line summary docstrings.

## 6. Testing Strategy
- Unit tests target granular modules (`tests/unit/...`). Add new tests adjacent to similar domain (e.g., new utility → `tests/unit/utilities/`).
- Integration tests at `tests/integration` cover full pipelines.
- Coverage thresholds enforced (e.g. `--cov-fail-under=80`). Keep defensive code minimal; exclude per coverage config if necessary.
- Regression fixtures live under `tests/data`; keep golden assets deterministic and update expectations intentionally.
- Pytest options for parallel execution (`-n auto`) are supported; prefer
  `pixi run -e dev pytest -n auto` for heavier suites.

## 7. Logging & Observability
- Exceptions in `{{ project_slug }}.exceptions` automatically emit log messages; keep
  error text concise and user-facing.
- CLI commands should surface actionable messages and exit codes without
  relying on hidden background logging.

## 8. Implementing a Sample Feature (Reference Flow)
Example: Add a new module.
1. Create `{{ project_slug }}/<module_name>.py` (or `{{ project_slug }}/utilities/<module_name>.py`)
   with the new module logic and corresponding docstrings.
2. Wire the feature into the CLI in `{{ project_slug }}/cli.py`.
3. Add tests in `tests/test_<module_name>.py` (or `tests/utilities/test_<module_name>.py`).
4. Run `pixi run -e dev tests` and refresh regression assets as needed.

## 9. CI/Release Lifecycle
- PR: Ruff lint → tests (locked + multi-OS). Fix lint first to avoid wasted CI cycles.
- Docs must build with `--fail-on-warning`; ensure new references are valid.
- Publishing uses `wheels.yml`; tags `v*` trigger the release.
- When touching documentation, ensure Sphinx builds remain warning-free under the `doc` environment.

## 10. Contribution & Style Extensions
- Follow Development Guidelines in `docs/dev.rst` for deeper details.
- Keep functions small; prefer pure helpers in `utilities/` with focused responsibilities.
- Prefer simple dicts over dataclasses.
- Avoid complex inheritance.
